Гит. Начальный уровень

Содержание

Комманды часто используемые в работе 
    Pull
    Push
    Fetch
    Чем отличается git pull от git fetch?

...

Операции отмены
    Горячая правка коммита (сообщения коммита): --amend
    Отмена индексации файла: git reset HEAD <file>
    Отмена изменений в файле: git checkout -- <file>
    
Комманды, которые вам скорей всего не надо трогать

Восстановление данных
    

ИЗНАЧАЛЬНАЯ ЦЕЛЬ: Удалить цепочку коммитов, сделав текущий коммит первым и единственным.
    КОММАНДА:
_______________________________________________________

Комманды часто используемые в работе 

После изученых основных комманд (см. ./git_start.txt): config, init, status, add, commit, log, checkout, show, как правило нам могут понадобиться следующие: pull, push, fetch. О них подробнее:

_______________________________________________________

___ Pull

См. Fetch
_______________________________________________________

___ Push

    Заливать (пушить) изменения в удаленный (remote) репозиторий можно всего одной командой - push:

$ git push

    Но как я сейчас понимаю, это возможно только до того момента, пока в репозитории всего одна ветка (branch).

$ git branch

> * main

    Когда же их будет более одной (это необязательно) то нужно будет указывать ветки непосредственно.
    Например:

$ git push origin master

    origin и master выдаются автоматически, но вместо master иногда назначается main (какие-то внутренние терки комьюнити, как я понял).
    Но, всегда можно узнать имя своей локальной и удаленной (remote) веток командами:

$ git branch #имя локальной ветки.
> * main

$ git remote #имя удаленной (remote) ветки.

> origin

    Пока они main и origin можно сокращать команду push до:
    
$ git push

____________________________________________________________________________

___ Fetch

    
______________________________________________________________________

___ Чем отличается git pull от git fetch?

Команда pull автоматически сливает коммиты, не давая вам сначала просмотреть их. Если вы не пристально следите за ветками, выполнение этой команды может привести к частым конфликтам.
При использовании fetch, git собирает все коммиты из целевой ветки, которых нет в текущей ветке, и сохраняет их в локальном репозитории. Однако он не сливает их в текущую ветку.

_________________________________________________________

___ Возвращение файла к предыдущему состоянию

Гит позволяет вернуть выбранный файл к состоянию на момент определенного коммита. Это делается уже знакомой нам командой checkout, которую мы ранее использовали для переключения между ветками. Но она также может быть использована для переключения между коммитами (это довольно распространенная ситуация для Гита - использование одной команды для различных, на первый взгляд, слабо связанных задач).
В следующем примере мы возьмем файл hello.txt и откатим все изменения, совершенные над ним к первому коммиту. Чтобы сделать это, мы подставим в команду идентификатор нужного коммита, а также путь до файла:

$ git checkout 09bd8cc1 hello.txt

__________________________________

    Пока мы тупо коммитим и пушим, или только коммитим в локальный репо, все просто, но как только нужно что-то изменить — тут начинается пляска с бубном. Прежде всего для начинающего, конечно, пользователя Git. Например, сейчас я захотел удалить прошлые коммиты, чтобы и в локальном и в удаленном репо был только текущий, а прошлых, как будто и не было. Ищу команду... revert и reset не подходят. Начал последовательно читать мануал — сейчас начнутся заметки на будущее. Заметки будут касаться: branch, reset, revert, rebase, fetch, diff, cherry-pick. Последняя заметка будет целевая — в содержании указана, как — ИЗНАЧАЛЬНАЯ ЦЕЛЬ:
________________________________________
    
___ Создание новой ветки
    Основная ветка в каждом репозитории называется master. Чтобы создать еще одну ветку, используем команду branch <name>

$ git branch complete_solutions #Создал еще одну ветку для практики по командам. Содержимым будут законченные Python-модули с функциями-примерами и классами-примерами.
__________________________________
    
___ Переключение между ветками с предшествующим определением имеющихся веток:

$ git branch
> complete_solutions
> * main #Ветка в которой вы находитесь сейчас отмечена звездочкой (и цветом возможно, зависит от инструмента, например у меня Git Bash) - это main.

$ git checkout complete_solutions
> Switched to branch 'complete_solutions' #Говорит что переключились в ветку.

__________________________________

    Работа в другой ветке выглядит, на уровне файлов, как работа в другой папке, но вот только выйти из неё чтобы перейти в основную ветвь, средствами операционной системы (Проводника) нельзя (способ есть, вот только он вне парадигмы работы с git). Но переключив необходимую ветку в Git всегда можно получить нужное состояние файловой системы вашего проекта. Длительное время ветки параллельно не существуют, так как в этом нет смысла. Поэтому как только необходимого функционала добились, альтернативную ветку сливают (мержат - merge) с основной веткой. Сказал, как понял.

$ git merge complete_solutions

    Ветку complete_solutions можно удалить, если не нужна. Только сперва нужно из нее выйти (переключиться в main, например)

$ git branch -d complete_solutions

Если хотите создать копию удаленного репозитория - используйте git clone. Однако если вам нужна только определенная его ветка, а не все хранилище - после git clone выполните следующую команду в соответствующем репозитории:

git checkout -b <имя ветки> origin/<имя ветки>
После этого, новая ветка создается на машине автоматически.

________________________________________________________

    Операции отмены

________________________________________________________

    Горячая правка коммита (сообщения коммита): --amend

    Git обычно только добавляет данные. Когда вы производите какие-либо действия в Git, практически все из них только добавляют новые данные в базу Git. Очень сложно заставить систему удалить данные либо сделать что-то, что нельзя впоследствии отменить. Как и в любой другой СКВ, вы можете потерять или испортить свои изменения, пока они не зафиксированы, но после того, как вы зафиксируете снимок в Git, будет очень сложно что-либо потерять, особенно, если вы регулярно синхронизируете свою базу с другим репозиторием.

    Однако, если вдруг что-то пошло не по плану может потребоваться ОТМЕНА. Например, если вы сделали коммит слишком рано, забыв добавить какие-то файлы или комментарий к коммиту. Если вы хотите переделать коммит — внесите необходимые изменения, добавьте их в индекс и сделайте коммит ещё раз, указав параметр --amend:

$ git commit -m 'Initial commit'
$ git add forgotten_file
$ git commit --amend

    Эта команда использует область подготовки (индекс) для внесения правок в коммит. Если вы ничего не меняли с момента последнего коммита (например, команда запущена сразу после предыдущего коммита), то снимок состояния останется в точности таким же, а всё что вы сможете изменить — это ваше сообщение к коммиту.

    Запустится тот же редактор, только он уже будет содержать сообщение предыдущего коммита. Вы можете редактировать сообщение как обычно, однако, оно заменит сообщение предыдущего коммита.

    Очевидно, смысл изменения коммитов в добавлении незначительных правок в последние коммиты и, при этом, в избежании засорения истории сообщениями вида «Ой, забыл добавить файл» или «Исправление грамматической ошибки».

_______________________________________________________

Отмена индексации файла: git reset HEAD <file>

Следующие два раздела демонстрируют как работать с индексом и изменениями в рабочем каталоге. Радует, что команда, которой вы определяете состояние этих областей, также подсказывает вам как отменять изменения в них. Например, вы изменили два файла и хотите добавить их в разные коммиты, но случайно выполнили команду git add * и добавили в индекс оба. Как исключить из индекса один из них? Команда git status напомнит вам:

$ git add *
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    renamed:    README.md -> README
    modified:   CONTRIBUTING.md
Прямо под текстом «Changes to be committed» говорится: используйте git reset HEAD <file>…​ для исключения из индекса. Давайте последуем этому совету и отменим индексирование файла CONTRIBUTING.md:

$ git reset HEAD CONTRIBUTING.md
Unstaged changes after reset:
M	CONTRIBUTING.md
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    renamed:    README.md -> README

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md
Команда выглядит несколько странно, но — работает! Файл CONTRIBUTING.md изменен, но больше не добавлен в индекс.

________________________________________________________

    Отмена изменений в файле: git checkout -- <file>

    Что делать, если вы поняли, что не хотите сохранять свои изменения файла CONTRIBUTING.md? Как можно просто отменить изменения в нём — вернуть к тому состоянию, которое было в последнем коммите (или к начальному после клонирования, или еще как-то полученному)? Нам повезло, что git status подсказывает и это тоже.

    В выводе команды из последнего примера список изменений выглядит примерно так:

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md

Здесь явно сказано как отменить существующие изменения. Давайте так и сделаем:

$ git checkout -- CONTRIBUTING.md
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    renamed:    README.md -> README
Как видите, откат изменений выполнен.


Помните, все что попало в коммит почти всегда Git может восстановить. Можно восстановить даже коммиты из веток, которые были удалены, или коммиты, перезаписанные параметром --amend (см. Восстановление данных). Но всё, что не было включено в коммит и потеряно — скорее всего, потеряно навсегда.

________________________________________________________

    Комманды, которые вам скорей всего не надо трогать

    - git reset может быть опасной если вызвать её с параметром --hard.
    - git checkout -- <file> — может быть опасна. Все локальные изменения в файле пропадут — Git просто заменит его версией из последнего коммита. Ни в коем случае не используйте эту команду, если вы не уверены, что изменения в файле вам не нужны.

Помните, все что попало в коммит почти всегда Git может восстановить. Можно восстановить даже коммиты из веток, которые были удалены, или коммиты, перезаписанные параметром --amend (см. Восстановление данных). Но всё, что не было включено в коммит и потеряно — скорее всего, потеряно навсегда.
    - git restore <file> — тоже довольно опасна. Любые локальные изменения, внесенные в этот файл, исчезнут — Git просто заменит файл последней зафиксированной версией. Никогда не используйте эту команду, если точно не знаете, нужны ли вам эти несохраненные локальные изменения.

________________________________________________________

Восстановление данных


________________________________
________________________________
________________________________