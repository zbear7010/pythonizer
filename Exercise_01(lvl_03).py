'''
Упражнение #01. Level #03.
'''

##
# Вариант с позиционным подходом к назначению переменных и выводом с помощью метода format.\n",
# Также при отрисовке заполнителя учитывается переменная длина списка с данными ФИО.\n",
# Тяжеловеснее выглядит примерно в 2 раза, по сравнению с предыдущими.\n",

# Список с элементами адреса определенного лица.
address_id001 = ["443322", "Москва", "Ленина пр-т", "д. 7", "кв. 1"]

# Список с ФИО персоны, связанный с адресом и заметками посредством id (id не в классическом смысле, а в смысле приставки _id001..002..N к именам переменных).
person_id001 = ["Иванов", "Иван", "Иванович"]

# Длинная заметка для тестирования.
note_id001 = "Lorem ipsum dolor sit amet consectetur adipisicing elit. Lorem ipsum dolor sit amet consectetur adipisicing elit. Lorem ipsum dolor s"

# Короткая заметка для тестирования.
# note_id001 = "Lorem ipsum."

'''
    С помощью метода format, можно задавать фиксированную длину отображению данных. 
    Задавать заполнитель, если данные разной длины, как в содержании книг, т.н. "отточие",
    в роли которых может выступать любой знак. Ещё центрировать данные в выбранном фиксированном пространстве.
    А также "распаковывать" списки.
'''

# Длина ФИО (количество всех символов). Задумка задать фиксированную ширину по ФИО, ...
# ... а для ниже лежащей строки \"Заметки: \" ограничить длину по вышерасположенному ФИО.

len_all_items = 0

for item in address_id001:
    len_all_items += len(item)

#
print("Длина сборного адресного поля:", len_all_items)

# Длина строковых значений полей ФИО. Вычитаемая тройка — кол-во символов
# кроме непосредственных ФИО, т.е 2 пробела и точка (Ф_И_О.).
len_placeholder_for_person = len_all_items - 3

print("Длина поля ФИО:", len_all_items, "- 3 =",
      len_placeholder_for_person, "(3: 2 пробела и точка.)")

len_placeholder_for_note = len_placeholder_for_person + 12

print(len_placeholder_for_note)

len_for_note = len_all_items + 5

print(len_for_note)

# Дубликат для заметки, чтобы не потерять оригинальное содержание.
note_id001_dup = note_id001

# Если вычисляемая длина заметки больше длины адреса...
if len(note_id001) > len_all_items:
    # if len(note_id001) > len_all_items & len(note_id001) >  :

    # ... обрезаем дубликат заметки до максимально возможной в соответствии с
    # отведенной длины для поля заметок (len_for_note), затем обрезаем ещё три
    # символа с конца строкового значения заметки, добавляем многоточие и
    # количество скрытых символов, помещенных в квадратные скобки. Напомним: это
    # происходит только для заметок с длиной, превышающей суммарную длину строковых значений адреса.
    # Что
    note_id001_dup = note_id001_dup[0:len_for_note - 4] + \
        "..." + "[" + str(len(note_id001) - len_all_items - 2) + "]"


print('\nКуда: {}, г. {}, {}, {}, {}.\nКому: {:.>{}} {} {}.\nЗаметки: {:.>{}}'
      .format(address_id001[0], address_id001[1], address_id001[2], address_id001[3], address_id001[4],
              person_id001[0], len_placeholder_for_person,  person_id001[1], person_id001[2],
              note_id001_dup, len_placeholder_for_note
              )
      )

# TODO: Задокументировать модуль досконально (всё: что происходит, как и почему).
